// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: records.V2.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Profilog_Records_V2_NodeType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case server // = 1
  case web // = 2
  case device // = 3
  case app // = 4
  case sdk // = 5
  case user // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .server
    case 2: self = .web
    case 3: self = .device
    case 4: self = .app
    case 5: self = .sdk
    case 6: self = .user
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .server: return 1
    case .web: return 2
    case .device: return 3
    case .app: return 4
    case .sdk: return 5
    case .user: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Profilog_Records_V2_NodeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Profilog_Records_V2_NodeType] = [
    .unknown,
    .server,
    .web,
    .device,
    .app,
    .sdk,
    .user,
  ]
}

#endif  // swift(>=4.2)

enum Profilog_Records_V2_NodeChannel: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case api // = 1
  case rest // = 2
  case grpc // = 3
  case externalRest // = 4
  case externalGrpc // = 5
  case manualInput // = 6
  case voiceInput // = 7
  case bluetooth // = 8
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .api
    case 2: self = .rest
    case 3: self = .grpc
    case 4: self = .externalRest
    case 5: self = .externalGrpc
    case 6: self = .manualInput
    case 7: self = .voiceInput
    case 8: self = .bluetooth
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .api: return 1
    case .rest: return 2
    case .grpc: return 3
    case .externalRest: return 4
    case .externalGrpc: return 5
    case .manualInput: return 6
    case .voiceInput: return 7
    case .bluetooth: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Profilog_Records_V2_NodeChannel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Profilog_Records_V2_NodeChannel] = [
    .unknown,
    .api,
    .rest,
    .grpc,
    .externalRest,
    .externalGrpc,
    .manualInput,
    .voiceInput,
    .bluetooth,
  ]
}

#endif  // swift(>=4.2)

struct Profilog_Records_V2_PaginationSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var page: Int32 = 0

  var pageSize: Int32 = 0

  var sortDescending: Bool = false

  var disableTotalCount: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Profilog_Records_V2_NodeTypeFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Profilog_Records_V2_NodeType = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Profilog_Records_V2_NodeChannelFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channel: Profilog_Records_V2_NodeChannel = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// filtr uzlu zdroje
struct Profilog_Records_V2_NodeFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var typeFilter: Profilog_Records_V2_NodeTypeFilter {
    get {return _typeFilter ?? Profilog_Records_V2_NodeTypeFilter()}
    set {_typeFilter = newValue}
  }
  /// Returns true if `typeFilter` has been explicitly set.
  var hasTypeFilter: Bool {return self._typeFilter != nil}
  /// Clears the value of `typeFilter`. Subsequent reads from it will return its default value.
  mutating func clearTypeFilter() {self._typeFilter = nil}

  var channelFilter: Profilog_Records_V2_NodeChannelFilter {
    get {return _channelFilter ?? Profilog_Records_V2_NodeChannelFilter()}
    set {_channelFilter = newValue}
  }
  /// Returns true if `channelFilter` has been explicitly set.
  var hasChannelFilter: Bool {return self._channelFilter != nil}
  /// Clears the value of `channelFilter`. Subsequent reads from it will return its default value.
  mutating func clearChannelFilter() {self._channelFilter = nil}

  /// název poskytovatele záznamu v daném uzlu (např. garmin, googleFit, user, Forerunner 55)
  var provider: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _provider ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_provider = newValue}
  }
  /// Returns true if `provider` has been explicitly set.
  var hasProvider: Bool {return self._provider != nil}
  /// Clears the value of `provider`. Subsequent reads from it will return its default value.
  mutating func clearProvider() {self._provider = nil}

  /// pořadí uzlu ve zdroji (level 1 je vždy poslední uzel, kudy záznam prošel)
  var level: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _level ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_level = newValue}
  }
  /// Returns true if `level` has been explicitly set.
  var hasLevel: Bool {return self._level != nil}
  /// Clears the value of `level`. Subsequent reads from it will return its default value.
  mutating func clearLevel() {self._level = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _typeFilter: Profilog_Records_V2_NodeTypeFilter? = nil
  fileprivate var _channelFilter: Profilog_Records_V2_NodeChannelFilter? = nil
  fileprivate var _provider: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _level: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

struct Profilog_Records_V2_SourceFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// zdroj musí mít aspoň 1 node
  var nodeFilters: [Profilog_Records_V2_NodeFilter] = []

  /// nepoužívá se
  var origin: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _origin ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  var hasOrigin: Bool {return self._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  mutating func clearOrigin() {self._origin = nil}

  ///bool exact_match = 3; // deprecated
  var partialMatch: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _origin: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

struct Profilog_Records_V2_RecordFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// název typu záznamu/metriky/ parametru (např. BloodPressure, Wound, Steps)
  var recordTypeName: String = String()

  /// kolekce zdrojů, ze kterých požadujeme záznamy, pokud bude prázndá, budou vráceny zdroje všech záznamů
  var sourceFilters: [Profilog_Records_V2_SourceFilter] = []

  /// kolekce zdrojů, ze kterých záznamy nechceme
  var excludedSourceFilters: [Profilog_Records_V2_SourceFilter] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Profilog_Records_V2_DataPagination {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var totalCount: Int32 = 0

  var page: Int32 = 0

  var pageSize: Int32 = 0

  var sortDescending: Bool = false

  var hasNextPage_p: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Profilog_Records_V2_Node {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Profilog_Records_V2_NodeType = .unknown

  var channel: Profilog_Records_V2_NodeChannel = .unknown

  /// název poskytovatele záznamu v daném uzlu (např. garmin, googleFit, user, Forerunner 55)
  var provider: String = String()

  /// pořadí uzlu ve zdroji (level 1 je vždy poslední uzel, kudy záznam prošel)
  var level: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Profilog_Records_V2_Source {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodes: [Profilog_Records_V2_Node] = []

  /// nepoužívá se
  var origin: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _origin ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  var hasOrigin: Bool {return self._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  mutating func clearOrigin() {self._origin = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _origin: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

/// Field vždy obsahuje název a právě jednu hodnotu, číselnou, textovou, čas nebo kolekci dalších fieldů
struct Profilog_Records_V2_Field {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// název sledované hodnoty
  var name: String = String()

  var value: Profilog_Records_V2_Field.OneOf_Value? = nil

  var numeric: Double {
    get {
      if case .numeric(let v)? = value {return v}
      return 0
    }
    set {value = .numeric(newValue)}
  }

  var text: String {
    get {
      if case .text(let v)? = value {return v}
      return String()
    }
    set {value = .text(newValue)}
  }

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .timestamp(let v)? = value {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {value = .timestamp(newValue)}
  }

  var fields: [Profilog_Records_V2_Field] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case numeric(Double)
    case text(String)
    case timestamp(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    static func ==(lhs: Profilog_Records_V2_Field.OneOf_Value, rhs: Profilog_Records_V2_Field.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.numeric, .numeric): return {
        guard case .numeric(let l) = lhs, case .numeric(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.timestamp, .timestamp): return {
        guard case .timestamp(let l) = lhs, case .timestamp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Profilog_Records_V2_Record {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  /// název typu záznamu/metriky/ parametru (např. BloodPressure, Wound, Steps)
  var recordTypeName: String = String()

  /// začátek záznamu
  var startAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startAt = newValue}
  }
  /// Returns true if `startAt` has been explicitly set.
  var hasStartAt: Bool {return self._startAt != nil}
  /// Clears the value of `startAt`. Subsequent reads from it will return its default value.
  mutating func clearStartAt() {self._startAt = nil}

  /// konec záznamu (v případě okamžikových záznamů je shodný se start_at)
  var endAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endAt = newValue}
  }
  /// Returns true if `endAt` has been explicitly set.
  var hasEndAt: Bool {return self._endAt != nil}
  /// Clears the value of `endAt`. Subsequent reads from it will return its default value.
  mutating func clearEndAt() {self._endAt = nil}

  /// čas, kdy byl záznam zaznamenán
  var recordedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _recordedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_recordedAt = newValue}
  }
  /// Returns true if `recordedAt` has been explicitly set.
  var hasRecordedAt: Bool {return self._recordedAt != nil}
  /// Clears the value of `recordedAt`. Subsequent reads from it will return its default value.
  mutating func clearRecordedAt() {self._recordedAt = nil}

  var source: Profilog_Records_V2_Source {
    get {return _source ?? Profilog_Records_V2_Source()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  /// jedna nebo více naměřených hodnot záznamu (např. počet kroků záznamu Steps nebo systolický a diastolický tlak záznamu BloodPressure)
  var fields: [Profilog_Records_V2_Field] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _recordedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _source: Profilog_Records_V2_Source? = nil
}

struct Profilog_Records_V2_GetRawRecordsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paginationSettings: Profilog_Records_V2_PaginationSettings {
    get {return _paginationSettings ?? Profilog_Records_V2_PaginationSettings()}
    set {_paginationSettings = newValue}
  }
  /// Returns true if `paginationSettings` has been explicitly set.
  var hasPaginationSettings: Bool {return self._paginationSettings != nil}
  /// Clears the value of `paginationSettings`. Subsequent reads from it will return its default value.
  mutating func clearPaginationSettings() {self._paginationSettings = nil}

  /// id subjektu, kterého záznamy požadujeme
  var medicalSubjectID: Int32 = 0

  var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  mutating func clearFrom() {self._from = nil}

  var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  mutating func clearTo() {self._to = nil}

  var recordFilters: [Profilog_Records_V2_RecordFilter] = []

  var includePredictedValues: Bool = false

  var useNewRecords: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _paginationSettings: Profilog_Records_V2_PaginationSettings? = nil
  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Profilog_Records_V2_GetRawRecordsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pagination: Profilog_Records_V2_DataPagination {
    get {return _pagination ?? Profilog_Records_V2_DataPagination()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var records: [Profilog_Records_V2_Record] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Profilog_Records_V2_DataPagination? = nil
}

struct Profilog_Records_V2_SynchronizeRecordsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id subjektu, kterému záznam patří
  var medicalSubjectID: Int32 = 0

  /// nepoužívá se
  var createSession: Bool = false

  /// název časové zóny ve formátu IANA, ve které došlo ke zaznemenání, pokud je známá
  var timeZoneIanaName: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _timeZoneIanaName ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_timeZoneIanaName = newValue}
  }
  /// Returns true if `timeZoneIanaName` has been explicitly set.
  var hasTimeZoneIanaName: Bool {return self._timeZoneIanaName != nil}
  /// Clears the value of `timeZoneIanaName`. Subsequent reads from it will return its default value.
  mutating func clearTimeZoneIanaName() {self._timeZoneIanaName = nil}

  /// offset v minutách od času UTC zaznamenání, pokud je znám (pokud je nastavena zóna, není potřeba)
  var offsetFromUtcMinutes: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _offsetFromUtcMinutes ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_offsetFromUtcMinutes = newValue}
  }
  /// Returns true if `offsetFromUtcMinutes` has been explicitly set.
  var hasOffsetFromUtcMinutes: Bool {return self._offsetFromUtcMinutes != nil}
  /// Clears the value of `offsetFromUtcMinutes`. Subsequent reads from it will return its default value.
  mutating func clearOffsetFromUtcMinutes() {self._offsetFromUtcMinutes = nil}

  /// skupiny záznamů, v každé skupině jsou vždy záznamy jednoho typu a ze stejného zdroje a synchronizují se samostatně
  var recordGroups: [Profilog_Records_V2_SynchronizeRecordsRequest.RecordGroup] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Record {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// začátek záznamu
    var startAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _startAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_startAt = newValue}
    }
    /// Returns true if `startAt` has been explicitly set.
    var hasStartAt: Bool {return self._startAt != nil}
    /// Clears the value of `startAt`. Subsequent reads from it will return its default value.
    mutating func clearStartAt() {self._startAt = nil}

    /// konec záznamu (v případě okamžikových záznamů je shodný se start_at)
    var endAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _endAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_endAt = newValue}
    }
    /// Returns true if `endAt` has been explicitly set.
    var hasEndAt: Bool {return self._endAt != nil}
    /// Clears the value of `endAt`. Subsequent reads from it will return its default value.
    mutating func clearEndAt() {self._endAt = nil}

    /// čas, kdy byl záznam zaznamenán
    var recordedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _recordedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_recordedAt = newValue}
    }
    /// Returns true if `recordedAt` has been explicitly set.
    var hasRecordedAt: Bool {return self._recordedAt != nil}
    /// Clears the value of `recordedAt`. Subsequent reads from it will return its default value.
    mutating func clearRecordedAt() {self._recordedAt = nil}

    /// jedna nebo více naměřených hodnot záznamu (např. počet kroků záznamu Steps nebo systolický a diastolický tlak záznamu BloodPressure)
    var fields: [Profilog_Records_V2_Field] = []

    /// if set, overrides value set in source.origin field 
    var origin: SwiftProtobuf.Google_Protobuf_StringValue {
      get {return _origin ?? SwiftProtobuf.Google_Protobuf_StringValue()}
      set {_origin = newValue}
    }
    /// Returns true if `origin` has been explicitly set.
    var hasOrigin: Bool {return self._origin != nil}
    /// Clears the value of `origin`. Subsequent reads from it will return its default value.
    mutating func clearOrigin() {self._origin = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _startAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _endAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _recordedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _origin: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  }

  struct RecordGroup {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// název typu záznamu/metriky/ parametru (např. BloodPressure, Wound, Steps)
    var recordTypeName: String = String()

    /// čas od kterého chceme provést synchronizaci
    var from: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_from = newValue}
    }
    /// Returns true if `from` has been explicitly set.
    var hasFrom: Bool {return self._from != nil}
    /// Clears the value of `from`. Subsequent reads from it will return its default value.
    mutating func clearFrom() {self._from = nil}

    /// čas do kterého chceme provést synchronizaci
    var to: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_to = newValue}
    }
    /// Returns true if `to` has been explicitly set.
    var hasTo: Bool {return self._to != nil}
    /// Clears the value of `to`. Subsequent reads from it will return its default value.
    mutating func clearTo() {self._to = nil}

    /// zdroj záznamů, synchronizace bude provedena pouze v rámci záznamů s tímto zdrojem a nově uložené záznamy budou mít právě tento zdroj
    var source: Profilog_Records_V2_Source {
      get {return _source ?? Profilog_Records_V2_Source()}
      set {_source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    var hasSource: Bool {return self._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    mutating func clearSource() {self._source = nil}

    /// kolekce záznamů, které se mají zanchronizovat (může být prázdná, v takovém případě dojde fakticky ke smazání všech existujících záznamů daného zdroje v rozmezí from - to)
    var records: [Profilog_Records_V2_SynchronizeRecordsRequest.Record] = []

    /// volitelné, pokud se záznamy mají synchronizovat v rámci podmnožiny záznamů danného zdroje (například se záznamy sychronizují pouze v rámci jedné rány s daným item_id)
    var itemID: SwiftProtobuf.Google_Protobuf_StringValue {
      get {return _itemID ?? SwiftProtobuf.Google_Protobuf_StringValue()}
      set {_itemID = newValue}
    }
    /// Returns true if `itemID` has been explicitly set.
    var hasItemID: Bool {return self._itemID != nil}
    /// Clears the value of `itemID`. Subsequent reads from it will return its default value.
    mutating func clearItemID() {self._itemID = nil}

    var upsertMode: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _source: Profilog_Records_V2_Source? = nil
    fileprivate var _itemID: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  }

  init() {}

  fileprivate var _timeZoneIanaName: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _offsetFromUtcMinutes: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

struct Profilog_Records_V2_SynchronizeRecordsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Profilog_Records_V2_NodeType: @unchecked Sendable {}
extension Profilog_Records_V2_NodeChannel: @unchecked Sendable {}
extension Profilog_Records_V2_PaginationSettings: @unchecked Sendable {}
extension Profilog_Records_V2_NodeTypeFilter: @unchecked Sendable {}
extension Profilog_Records_V2_NodeChannelFilter: @unchecked Sendable {}
extension Profilog_Records_V2_NodeFilter: @unchecked Sendable {}
extension Profilog_Records_V2_SourceFilter: @unchecked Sendable {}
extension Profilog_Records_V2_RecordFilter: @unchecked Sendable {}
extension Profilog_Records_V2_DataPagination: @unchecked Sendable {}
extension Profilog_Records_V2_Node: @unchecked Sendable {}
extension Profilog_Records_V2_Source: @unchecked Sendable {}
extension Profilog_Records_V2_Field: @unchecked Sendable {}
extension Profilog_Records_V2_Field.OneOf_Value: @unchecked Sendable {}
extension Profilog_Records_V2_Record: @unchecked Sendable {}
extension Profilog_Records_V2_GetRawRecordsRequest: @unchecked Sendable {}
extension Profilog_Records_V2_GetRawRecordsResponse: @unchecked Sendable {}
extension Profilog_Records_V2_SynchronizeRecordsRequest: @unchecked Sendable {}
extension Profilog_Records_V2_SynchronizeRecordsRequest.Record: @unchecked Sendable {}
extension Profilog_Records_V2_SynchronizeRecordsRequest.RecordGroup: @unchecked Sendable {}
extension Profilog_Records_V2_SynchronizeRecordsResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "profilog.records.v2"

extension Profilog_Records_V2_NodeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NODE_TYPE_UNKNOWN"),
    1: .same(proto: "NODE_TYPE_SERVER"),
    2: .same(proto: "NODE_TYPE_WEB"),
    3: .same(proto: "NODE_TYPE_DEVICE"),
    4: .same(proto: "NODE_TYPE_APP"),
    5: .same(proto: "NODE_TYPE_SDK"),
    6: .same(proto: "NODE_TYPE_USER"),
  ]
}

extension Profilog_Records_V2_NodeChannel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NODE_CHANNEL_UNKNOWN"),
    1: .same(proto: "NODE_CHANNEL_API"),
    2: .same(proto: "NODE_CHANNEL_REST"),
    3: .same(proto: "NODE_CHANNEL_GRPC"),
    4: .same(proto: "NODE_CHANNEL_EXTERNAL_REST"),
    5: .same(proto: "NODE_CHANNEL_EXTERNAL_GRPC"),
    6: .same(proto: "NODE_CHANNEL_MANUAL_INPUT"),
    7: .same(proto: "NODE_CHANNEL_VOICE_INPUT"),
    8: .same(proto: "NODE_CHANNEL_BLUETOOTH"),
  ]
}

extension Profilog_Records_V2_PaginationSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaginationSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "page"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "sort_descending"),
    4: .standard(proto: "disable_total_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.sortDescending) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.disableTotalCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if self.sortDescending != false {
      try visitor.visitSingularBoolField(value: self.sortDescending, fieldNumber: 3)
    }
    if self.disableTotalCount != false {
      try visitor.visitSingularBoolField(value: self.disableTotalCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_V2_PaginationSettings, rhs: Profilog_Records_V2_PaginationSettings) -> Bool {
    if lhs.page != rhs.page {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.sortDescending != rhs.sortDescending {return false}
    if lhs.disableTotalCount != rhs.disableTotalCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_V2_NodeTypeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeTypeFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_V2_NodeTypeFilter, rhs: Profilog_Records_V2_NodeTypeFilter) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_V2_NodeChannelFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeChannelFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.channel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channel != .unknown {
      try visitor.visitSingularEnumField(value: self.channel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_V2_NodeChannelFilter, rhs: Profilog_Records_V2_NodeChannelFilter) -> Bool {
    if lhs.channel != rhs.channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_V2_NodeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "type_filter"),
    2: .standard(proto: "channel_filter"),
    3: .same(proto: "provider"),
    4: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._typeFilter) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._channelFilter) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._provider) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._typeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._channelFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._provider {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._level {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_V2_NodeFilter, rhs: Profilog_Records_V2_NodeFilter) -> Bool {
    if lhs._typeFilter != rhs._typeFilter {return false}
    if lhs._channelFilter != rhs._channelFilter {return false}
    if lhs._provider != rhs._provider {return false}
    if lhs._level != rhs._level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_V2_SourceFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SourceFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_filters"),
    2: .same(proto: "origin"),
    4: .standard(proto: "partial_match"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeFilters) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.partialMatch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodeFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeFilters, fieldNumber: 1)
    }
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.partialMatch != false {
      try visitor.visitSingularBoolField(value: self.partialMatch, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_V2_SourceFilter, rhs: Profilog_Records_V2_SourceFilter) -> Bool {
    if lhs.nodeFilters != rhs.nodeFilters {return false}
    if lhs._origin != rhs._origin {return false}
    if lhs.partialMatch != rhs.partialMatch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_V2_RecordFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_type_name"),
    2: .standard(proto: "source_filters"),
    3: .standard(proto: "excluded_source_filters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recordTypeName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sourceFilters) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.excludedSourceFilters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recordTypeName.isEmpty {
      try visitor.visitSingularStringField(value: self.recordTypeName, fieldNumber: 1)
    }
    if !self.sourceFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sourceFilters, fieldNumber: 2)
    }
    if !self.excludedSourceFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.excludedSourceFilters, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_V2_RecordFilter, rhs: Profilog_Records_V2_RecordFilter) -> Bool {
    if lhs.recordTypeName != rhs.recordTypeName {return false}
    if lhs.sourceFilters != rhs.sourceFilters {return false}
    if lhs.excludedSourceFilters != rhs.excludedSourceFilters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_V2_DataPagination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataPagination"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_count"),
    2: .same(proto: "page"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "sort_descending"),
    5: .standard(proto: "has_next_page"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.totalCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.sortDescending) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.hasNextPage_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalCount, fieldNumber: 1)
    }
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if self.sortDescending != false {
      try visitor.visitSingularBoolField(value: self.sortDescending, fieldNumber: 4)
    }
    if self.hasNextPage_p != false {
      try visitor.visitSingularBoolField(value: self.hasNextPage_p, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_V2_DataPagination, rhs: Profilog_Records_V2_DataPagination) -> Bool {
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.page != rhs.page {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.sortDescending != rhs.sortDescending {return false}
    if lhs.hasNextPage_p != rhs.hasNextPage_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_V2_Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Node"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "channel"),
    3: .same(proto: "provider"),
    4: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.channel) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.provider) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.channel != .unknown {
      try visitor.visitSingularEnumField(value: self.channel, fieldNumber: 2)
    }
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 3)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_V2_Node, rhs: Profilog_Records_V2_Node) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_V2_Source: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Source"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .same(proto: "origin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_V2_Source, rhs: Profilog_Records_V2_Source) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs._origin != rhs._origin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_V2_Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Field"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "numeric"),
    3: .same(proto: "text"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .numeric(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .text(v)
        }
      }()
      case 4: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .timestamp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .timestamp(v)
        }
      }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.value {
    case .numeric?: try {
      guard case .numeric(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }()
    case .text?: try {
      guard case .text(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .timestamp?: try {
      guard case .timestamp(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_V2_Field, rhs: Profilog_Records_V2_Field) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_V2_Record: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Record"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "record_type_name"),
    3: .standard(proto: "start_at"),
    4: .standard(proto: "end_at"),
    7: .standard(proto: "recorded_at"),
    5: .same(proto: "source"),
    6: .same(proto: "fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.recordTypeName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._startAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._endAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._recordedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.recordTypeName.isEmpty {
      try visitor.visitSingularStringField(value: self.recordTypeName, fieldNumber: 2)
    }
    try { if let v = self._startAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._endAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 6)
    }
    try { if let v = self._recordedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_V2_Record, rhs: Profilog_Records_V2_Record) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.recordTypeName != rhs.recordTypeName {return false}
    if lhs._startAt != rhs._startAt {return false}
    if lhs._endAt != rhs._endAt {return false}
    if lhs._recordedAt != rhs._recordedAt {return false}
    if lhs._source != rhs._source {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_V2_GetRawRecordsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRawRecordsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pagination_settings"),
    2: .standard(proto: "medical_subject_id"),
    3: .same(proto: "from"),
    4: .same(proto: "to"),
    5: .standard(proto: "record_filters"),
    6: .standard(proto: "include_predicted_values"),
    99: .standard(proto: "use_new_records"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paginationSettings) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.medicalSubjectID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.recordFilters) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.includePredictedValues) }()
      case 99: try { try decoder.decodeSingularBoolField(value: &self.useNewRecords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paginationSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.medicalSubjectID != 0 {
      try visitor.visitSingularInt32Field(value: self.medicalSubjectID, fieldNumber: 2)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.recordFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recordFilters, fieldNumber: 5)
    }
    if self.includePredictedValues != false {
      try visitor.visitSingularBoolField(value: self.includePredictedValues, fieldNumber: 6)
    }
    if self.useNewRecords != false {
      try visitor.visitSingularBoolField(value: self.useNewRecords, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_V2_GetRawRecordsRequest, rhs: Profilog_Records_V2_GetRawRecordsRequest) -> Bool {
    if lhs._paginationSettings != rhs._paginationSettings {return false}
    if lhs.medicalSubjectID != rhs.medicalSubjectID {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.recordFilters != rhs.recordFilters {return false}
    if lhs.includePredictedValues != rhs.includePredictedValues {return false}
    if lhs.useNewRecords != rhs.useNewRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_V2_GetRawRecordsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRawRecordsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pagination"),
    2: .same(proto: "records"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_V2_GetRawRecordsResponse, rhs: Profilog_Records_V2_GetRawRecordsResponse) -> Bool {
    if lhs._pagination != rhs._pagination {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_V2_SynchronizeRecordsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SynchronizeRecordsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "medical_subject_id"),
    2: .standard(proto: "create_session"),
    3: .standard(proto: "time_zone_iana_name"),
    5: .standard(proto: "offset_from_utc_minutes"),
    4: .standard(proto: "record_groups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.medicalSubjectID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.createSession) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeZoneIanaName) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.recordGroups) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._offsetFromUtcMinutes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.medicalSubjectID != 0 {
      try visitor.visitSingularInt32Field(value: self.medicalSubjectID, fieldNumber: 1)
    }
    if self.createSession != false {
      try visitor.visitSingularBoolField(value: self.createSession, fieldNumber: 2)
    }
    try { if let v = self._timeZoneIanaName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.recordGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recordGroups, fieldNumber: 4)
    }
    try { if let v = self._offsetFromUtcMinutes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_V2_SynchronizeRecordsRequest, rhs: Profilog_Records_V2_SynchronizeRecordsRequest) -> Bool {
    if lhs.medicalSubjectID != rhs.medicalSubjectID {return false}
    if lhs.createSession != rhs.createSession {return false}
    if lhs._timeZoneIanaName != rhs._timeZoneIanaName {return false}
    if lhs._offsetFromUtcMinutes != rhs._offsetFromUtcMinutes {return false}
    if lhs.recordGroups != rhs.recordGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_V2_SynchronizeRecordsRequest.Record: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_V2_SynchronizeRecordsRequest.protoMessageName + ".Record"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_at"),
    2: .standard(proto: "end_at"),
    5: .standard(proto: "recorded_at"),
    3: .same(proto: "fields"),
    4: .same(proto: "origin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endAt) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._recordedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 3)
    }
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._recordedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_V2_SynchronizeRecordsRequest.Record, rhs: Profilog_Records_V2_SynchronizeRecordsRequest.Record) -> Bool {
    if lhs._startAt != rhs._startAt {return false}
    if lhs._endAt != rhs._endAt {return false}
    if lhs._recordedAt != rhs._recordedAt {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs._origin != rhs._origin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_V2_SynchronizeRecordsRequest.RecordGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_V2_SynchronizeRecordsRequest.protoMessageName + ".RecordGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_type_name"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .same(proto: "source"),
    5: .same(proto: "records"),
    6: .standard(proto: "item_id"),
    7: .same(proto: "UpsertMode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recordTypeName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._itemID) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.upsertMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.recordTypeName.isEmpty {
      try visitor.visitSingularStringField(value: self.recordTypeName, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 5)
    }
    try { if let v = self._itemID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.upsertMode != false {
      try visitor.visitSingularBoolField(value: self.upsertMode, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_V2_SynchronizeRecordsRequest.RecordGroup, rhs: Profilog_Records_V2_SynchronizeRecordsRequest.RecordGroup) -> Bool {
    if lhs.recordTypeName != rhs.recordTypeName {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs._source != rhs._source {return false}
    if lhs.records != rhs.records {return false}
    if lhs._itemID != rhs._itemID {return false}
    if lhs.upsertMode != rhs.upsertMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_V2_SynchronizeRecordsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SynchronizeRecordsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_V2_SynchronizeRecordsResponse, rhs: Profilog_Records_V2_SynchronizeRecordsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
