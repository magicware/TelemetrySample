// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: records.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Profilog_Records_NodeType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case server // = 1
  case web // = 2
  case device // = 3
  case app // = 4
  case sdk // = 5
  case user // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .server
    case 2: self = .web
    case 3: self = .device
    case 4: self = .app
    case 5: self = .sdk
    case 6: self = .user
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .server: return 1
    case .web: return 2
    case .device: return 3
    case .app: return 4
    case .sdk: return 5
    case .user: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Profilog_Records_NodeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Profilog_Records_NodeType] = [
    .unknown,
    .server,
    .web,
    .device,
    .app,
    .sdk,
    .user,
  ]
}

#endif  // swift(>=4.2)

enum Profilog_Records_NodeChannel: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case api // = 1
  case rest // = 2
  case grpc // = 3
  case externalRest // = 4
  case externalGrpc // = 5
  case manualInput // = 6
  case voiceInput // = 7
  case bluetooth // = 8
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .api
    case 2: self = .rest
    case 3: self = .grpc
    case 4: self = .externalRest
    case 5: self = .externalGrpc
    case 6: self = .manualInput
    case 7: self = .voiceInput
    case 8: self = .bluetooth
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .api: return 1
    case .rest: return 2
    case .grpc: return 3
    case .externalRest: return 4
    case .externalGrpc: return 5
    case .manualInput: return 6
    case .voiceInput: return 7
    case .bluetooth: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Profilog_Records_NodeChannel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Profilog_Records_NodeChannel] = [
    .unknown,
    .api,
    .rest,
    .grpc,
    .externalRest,
    .externalGrpc,
    .manualInput,
    .voiceInput,
    .bluetooth,
  ]
}

#endif  // swift(>=4.2)

struct Profilog_Records_BucketSize {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timeUnit: Profilog_Records_BucketSize.TimeUnit = .second

  var resolution: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TimeUnit: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case second // = 0
    case minute // = 1
    case hour // = 2
    case day // = 3
    case month // = 4
    case wholeRange // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .second
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .second
      case 1: self = .minute
      case 2: self = .hour
      case 3: self = .day
      case 4: self = .month
      case 5: self = .wholeRange
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .second: return 0
      case .minute: return 1
      case .hour: return 2
      case .day: return 3
      case .month: return 4
      case .wholeRange: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Profilog_Records_BucketSize.TimeUnit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Profilog_Records_BucketSize.TimeUnit] = [
    .second,
    .minute,
    .hour,
    .day,
    .month,
    .wholeRange,
  ]
}

#endif  // swift(>=4.2)

struct Profilog_Records_Field {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var value: Profilog_Records_Field.OneOf_Value? = nil

  var numeric: Double {
    get {
      if case .numeric(let v)? = value {return v}
      return 0
    }
    set {value = .numeric(newValue)}
  }

  var text: String {
    get {
      if case .text(let v)? = value {return v}
      return String()
    }
    set {value = .text(newValue)}
  }

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .timestamp(let v)? = value {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {value = .timestamp(newValue)}
  }

  var fields: [Profilog_Records_Field] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case numeric(Double)
    case text(String)
    case timestamp(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    static func ==(lhs: Profilog_Records_Field.OneOf_Value, rhs: Profilog_Records_Field.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.numeric, .numeric): return {
        guard case .numeric(let l) = lhs, case .numeric(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.timestamp, .timestamp): return {
        guard case .timestamp(let l) = lhs, case .timestamp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Not merged and not bucketed - supported
/// Merged and not bucketed - supported
/// Not merged and bucketed - NOT supported (records are always merged when bucketed)
/// Merged and bucketed - supported
struct Profilog_Records_GetRecordsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var medicalSubjectID: Int32 = 0

  var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  mutating func clearFrom() {self._from = nil}

  var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  mutating func clearTo() {self._to = nil}

  var destinationTimeZoneIanaName: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _destinationTimeZoneIanaName ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_destinationTimeZoneIanaName = newValue}
  }
  /// Returns true if `destinationTimeZoneIanaName` has been explicitly set.
  var hasDestinationTimeZoneIanaName: Bool {return self._destinationTimeZoneIanaName != nil}
  /// Clears the value of `destinationTimeZoneIanaName`. Subsequent reads from it will return its default value.
  mutating func clearDestinationTimeZoneIanaName() {self._destinationTimeZoneIanaName = nil}

  var recordGroups: [Profilog_Records_GetRecordsRequest.RecordGroup] = []

  var useNewRecords: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct RecordGroup {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var recordTypeName: String = String()

    var sources: [Profilog_Records_GetRecordsRequest.SourceFilter] = []

    var excludedSources: [Profilog_Records_GetRecordsRequest.SourceFilter] = []

    var doMerge: Bool = false

    var bucketSize: Profilog_Records_BucketSize {
      get {return _bucketSize ?? Profilog_Records_BucketSize()}
      set {_bucketSize = newValue}
    }
    /// Returns true if `bucketSize` has been explicitly set.
    var hasBucketSize: Bool {return self._bucketSize != nil}
    /// Clears the value of `bucketSize`. Subsequent reads from it will return its default value.
    mutating func clearBucketSize() {self._bucketSize = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bucketSize: Profilog_Records_BucketSize? = nil
  }

  struct SourceFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodes: [Profilog_Records_GetRecordsRequest.NodeFilter] = []

    var origin: SwiftProtobuf.Google_Protobuf_StringValue {
      get {return _origin ?? SwiftProtobuf.Google_Protobuf_StringValue()}
      set {_origin = newValue}
    }
    /// Returns true if `origin` has been explicitly set.
    var hasOrigin: Bool {return self._origin != nil}
    /// Clears the value of `origin`. Subsequent reads from it will return its default value.
    mutating func clearOrigin() {self._origin = nil}

    var partialMatch: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _origin: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  }

  struct NodeFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Profilog_Records_GetRecordsRequest.NodeFilter.TypeFilter {
      get {return _type ?? Profilog_Records_GetRecordsRequest.NodeFilter.TypeFilter()}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var channel: Profilog_Records_GetRecordsRequest.NodeFilter.ChannelFilter {
      get {return _channel ?? Profilog_Records_GetRecordsRequest.NodeFilter.ChannelFilter()}
      set {_channel = newValue}
    }
    /// Returns true if `channel` has been explicitly set.
    var hasChannel: Bool {return self._channel != nil}
    /// Clears the value of `channel`. Subsequent reads from it will return its default value.
    mutating func clearChannel() {self._channel = nil}

    var provider: SwiftProtobuf.Google_Protobuf_StringValue {
      get {return _provider ?? SwiftProtobuf.Google_Protobuf_StringValue()}
      set {_provider = newValue}
    }
    /// Returns true if `provider` has been explicitly set.
    var hasProvider: Bool {return self._provider != nil}
    /// Clears the value of `provider`. Subsequent reads from it will return its default value.
    mutating func clearProvider() {self._provider = nil}

    var level: SwiftProtobuf.Google_Protobuf_Int32Value {
      get {return _level ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
      set {_level = newValue}
    }
    /// Returns true if `level` has been explicitly set.
    var hasLevel: Bool {return self._level != nil}
    /// Clears the value of `level`. Subsequent reads from it will return its default value.
    mutating func clearLevel() {self._level = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct ChannelFilter {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var channel: Profilog_Records_NodeChannel = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct TypeFilter {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var type: Profilog_Records_NodeType = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _type: Profilog_Records_GetRecordsRequest.NodeFilter.TypeFilter? = nil
    fileprivate var _channel: Profilog_Records_GetRecordsRequest.NodeFilter.ChannelFilter? = nil
    fileprivate var _provider: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    fileprivate var _level: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  }

  init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _destinationTimeZoneIanaName: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

struct Profilog_Records_GetRecordsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var medicalSubjectID: Int32 = 0

  var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  mutating func clearFrom() {self._from = nil}

  var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  mutating func clearTo() {self._to = nil}

  var timeZoneIanaName: String = String()

  var recordGroups: [Profilog_Records_GetRecordsResponse.RecordGroup] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct RecordGroup {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var recordTypeName: String = String()

    var data: Profilog_Records_GetRecordsResponse.RecordGroup.OneOf_Data? = nil

    var rawRecords: Profilog_Records_GetRecordsResponse.RawRecords {
      get {
        if case .rawRecords(let v)? = data {return v}
        return Profilog_Records_GetRecordsResponse.RawRecords()
      }
      set {data = .rawRecords(newValue)}
    }

    var bucketRecords: Profilog_Records_GetRecordsResponse.BucketRecords {
      get {
        if case .bucketRecords(let v)? = data {return v}
        return Profilog_Records_GetRecordsResponse.BucketRecords()
      }
      set {data = .bucketRecords(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Data: Equatable {
      case rawRecords(Profilog_Records_GetRecordsResponse.RawRecords)
      case bucketRecords(Profilog_Records_GetRecordsResponse.BucketRecords)

    #if !swift(>=4.1)
      static func ==(lhs: Profilog_Records_GetRecordsResponse.RecordGroup.OneOf_Data, rhs: Profilog_Records_GetRecordsResponse.RecordGroup.OneOf_Data) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.rawRecords, .rawRecords): return {
          guard case .rawRecords(let l) = lhs, case .rawRecords(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.bucketRecords, .bucketRecords): return {
          guard case .bucketRecords(let l) = lhs, case .bucketRecords(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  struct RawRecords {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var isMerged: Bool = false

    var records: [Profilog_Records_GetRecordsResponse.Record] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Record {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var startAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _startAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_startAt = newValue}
    }
    /// Returns true if `startAt` has been explicitly set.
    var hasStartAt: Bool {return self._startAt != nil}
    /// Clears the value of `startAt`. Subsequent reads from it will return its default value.
    mutating func clearStartAt() {self._startAt = nil}

    var endAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _endAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_endAt = newValue}
    }
    /// Returns true if `endAt` has been explicitly set.
    var hasEndAt: Bool {return self._endAt != nil}
    /// Clears the value of `endAt`. Subsequent reads from it will return its default value.
    mutating func clearEndAt() {self._endAt = nil}

    var source: Profilog_Records_GetRecordsResponse.Source {
      get {return _source ?? Profilog_Records_GetRecordsResponse.Source()}
      set {_source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    var hasSource: Bool {return self._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    mutating func clearSource() {self._source = nil}

    var fields: [Profilog_Records_Field] = []

    var id: SwiftProtobuf.Google_Protobuf_StringValue {
      get {return _id ?? SwiftProtobuf.Google_Protobuf_StringValue()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _startAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _endAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _source: Profilog_Records_GetRecordsResponse.Source? = nil
    fileprivate var _id: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  }

  struct Source {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodes: [Profilog_Records_GetRecordsResponse.Node] = []

    var origin: SwiftProtobuf.Google_Protobuf_StringValue {
      get {return _origin ?? SwiftProtobuf.Google_Protobuf_StringValue()}
      set {_origin = newValue}
    }
    /// Returns true if `origin` has been explicitly set.
    var hasOrigin: Bool {return self._origin != nil}
    /// Clears the value of `origin`. Subsequent reads from it will return its default value.
    mutating func clearOrigin() {self._origin = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _origin: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  }

  struct Node {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var channel: Profilog_Records_NodeChannel = .unknown

    var provider: String = String()

    var level: Int32 = 0

    var type: Profilog_Records_NodeType = .unknown

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BucketRecords {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bucketSize: Profilog_Records_BucketSize {
      get {return _bucketSize ?? Profilog_Records_BucketSize()}
      set {_bucketSize = newValue}
    }
    /// Returns true if `bucketSize` has been explicitly set.
    var hasBucketSize: Bool {return self._bucketSize != nil}
    /// Clears the value of `bucketSize`. Subsequent reads from it will return its default value.
    mutating func clearBucketSize() {self._bucketSize = nil}

    var buckets: [Profilog_Records_GetRecordsResponse.Bucket] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bucketSize: Profilog_Records_BucketSize? = nil
  }

  struct Bucket {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var startAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _startAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_startAt = newValue}
    }
    /// Returns true if `startAt` has been explicitly set.
    var hasStartAt: Bool {return self._startAt != nil}
    /// Clears the value of `startAt`. Subsequent reads from it will return its default value.
    mutating func clearStartAt() {self._startAt = nil}

    var endAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _endAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_endAt = newValue}
    }
    /// Returns true if `endAt` has been explicitly set.
    var hasEndAt: Bool {return self._endAt != nil}
    /// Clears the value of `endAt`. Subsequent reads from it will return its default value.
    mutating func clearEndAt() {self._endAt = nil}

    var aggregatedFields: [Profilog_Records_GetRecordsResponse.AggregatedField] = []

    var aggregationMetrics: [Profilog_Records_GetRecordsResponse.AggregationMetric] = []

    var sources: [Profilog_Records_GetRecordsResponse.Source] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _startAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _endAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  struct AggregatedField {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var count: Int32 = 0

    var max: Double = 0

    var min: Double = 0

    var avg: Double = 0

    var sum: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct AggregationMetric {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var value: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Profilog_Records_SaveRecordsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var medicalSubjectID: Int32 = 0

  var createSession: Bool = false

  var timeZoneIanaName: String = String()

  var recordGroups: [Profilog_Records_SaveRecordsRequest.RecordGroup] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct RecordGroup {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var recordTypeName: String = String()

    var from: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_from = newValue}
    }
    /// Returns true if `from` has been explicitly set.
    var hasFrom: Bool {return self._from != nil}
    /// Clears the value of `from`. Subsequent reads from it will return its default value.
    mutating func clearFrom() {self._from = nil}

    var to: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_to = newValue}
    }
    /// Returns true if `to` has been explicitly set.
    var hasTo: Bool {return self._to != nil}
    /// Clears the value of `to`. Subsequent reads from it will return its default value.
    mutating func clearTo() {self._to = nil}

    var source: Profilog_Records_SaveRecordsRequest.Source {
      get {return _source ?? Profilog_Records_SaveRecordsRequest.Source()}
      set {_source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    var hasSource: Bool {return self._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    mutating func clearSource() {self._source = nil}

    var records: [Profilog_Records_SaveRecordsRequest.Record] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _source: Profilog_Records_SaveRecordsRequest.Source? = nil
  }

  struct Source {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodes: [Profilog_Records_SaveRecordsRequest.Node] = []

    var origin: SwiftProtobuf.Google_Protobuf_StringValue {
      get {return _origin ?? SwiftProtobuf.Google_Protobuf_StringValue()}
      set {_origin = newValue}
    }
    /// Returns true if `origin` has been explicitly set.
    var hasOrigin: Bool {return self._origin != nil}
    /// Clears the value of `origin`. Subsequent reads from it will return its default value.
    mutating func clearOrigin() {self._origin = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _origin: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  }

  struct Node {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var channel: Profilog_Records_NodeChannel = .unknown

    var provider: String = String()

    var level: Int32 = 0

    var type: Profilog_Records_NodeType = .unknown

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Record {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var startAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _startAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_startAt = newValue}
    }
    /// Returns true if `startAt` has been explicitly set.
    var hasStartAt: Bool {return self._startAt != nil}
    /// Clears the value of `startAt`. Subsequent reads from it will return its default value.
    mutating func clearStartAt() {self._startAt = nil}

    var endAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _endAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_endAt = newValue}
    }
    /// Returns true if `endAt` has been explicitly set.
    var hasEndAt: Bool {return self._endAt != nil}
    /// Clears the value of `endAt`. Subsequent reads from it will return its default value.
    mutating func clearEndAt() {self._endAt = nil}

    var fields: [Profilog_Records_Field] = []

    /// if set, overrides value set in source.origin field 
    var origin: SwiftProtobuf.Google_Protobuf_StringValue {
      get {return _origin ?? SwiftProtobuf.Google_Protobuf_StringValue()}
      set {_origin = newValue}
    }
    /// Returns true if `origin` has been explicitly set.
    var hasOrigin: Bool {return self._origin != nil}
    /// Clears the value of `origin`. Subsequent reads from it will return its default value.
    mutating func clearOrigin() {self._origin = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _startAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _endAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _origin: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  }

  init() {}
}

struct Profilog_Records_SaveRecordsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Profilog_Records_NodeType: @unchecked Sendable {}
extension Profilog_Records_NodeChannel: @unchecked Sendable {}
extension Profilog_Records_BucketSize: @unchecked Sendable {}
extension Profilog_Records_BucketSize.TimeUnit: @unchecked Sendable {}
extension Profilog_Records_Field: @unchecked Sendable {}
extension Profilog_Records_Field.OneOf_Value: @unchecked Sendable {}
extension Profilog_Records_GetRecordsRequest: @unchecked Sendable {}
extension Profilog_Records_GetRecordsRequest.RecordGroup: @unchecked Sendable {}
extension Profilog_Records_GetRecordsRequest.SourceFilter: @unchecked Sendable {}
extension Profilog_Records_GetRecordsRequest.NodeFilter: @unchecked Sendable {}
extension Profilog_Records_GetRecordsRequest.NodeFilter.ChannelFilter: @unchecked Sendable {}
extension Profilog_Records_GetRecordsRequest.NodeFilter.TypeFilter: @unchecked Sendable {}
extension Profilog_Records_GetRecordsResponse: @unchecked Sendable {}
extension Profilog_Records_GetRecordsResponse.RecordGroup: @unchecked Sendable {}
extension Profilog_Records_GetRecordsResponse.RecordGroup.OneOf_Data: @unchecked Sendable {}
extension Profilog_Records_GetRecordsResponse.RawRecords: @unchecked Sendable {}
extension Profilog_Records_GetRecordsResponse.Record: @unchecked Sendable {}
extension Profilog_Records_GetRecordsResponse.Source: @unchecked Sendable {}
extension Profilog_Records_GetRecordsResponse.Node: @unchecked Sendable {}
extension Profilog_Records_GetRecordsResponse.BucketRecords: @unchecked Sendable {}
extension Profilog_Records_GetRecordsResponse.Bucket: @unchecked Sendable {}
extension Profilog_Records_GetRecordsResponse.AggregatedField: @unchecked Sendable {}
extension Profilog_Records_GetRecordsResponse.AggregationMetric: @unchecked Sendable {}
extension Profilog_Records_SaveRecordsRequest: @unchecked Sendable {}
extension Profilog_Records_SaveRecordsRequest.RecordGroup: @unchecked Sendable {}
extension Profilog_Records_SaveRecordsRequest.Source: @unchecked Sendable {}
extension Profilog_Records_SaveRecordsRequest.Node: @unchecked Sendable {}
extension Profilog_Records_SaveRecordsRequest.Record: @unchecked Sendable {}
extension Profilog_Records_SaveRecordsResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "profilog.records"

extension Profilog_Records_NodeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NODE_TYPE_UNKNOWN"),
    1: .same(proto: "NODE_TYPE_SERVER"),
    2: .same(proto: "NODE_TYPE_WEB"),
    3: .same(proto: "NODE_TYPE_DEVICE"),
    4: .same(proto: "NODE_TYPE_APP"),
    5: .same(proto: "NODE_TYPE_SDK"),
    6: .same(proto: "NODE_TYPE_USER"),
  ]
}

extension Profilog_Records_NodeChannel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NODE_CHANNEL_UNKNOWN"),
    1: .same(proto: "NODE_CHANNEL_API"),
    2: .same(proto: "NODE_CHANNEL_REST"),
    3: .same(proto: "NODE_CHANNEL_GRPC"),
    4: .same(proto: "NODE_CHANNEL_EXTERNAL_REST"),
    5: .same(proto: "NODE_CHANNEL_EXTERNAL_GRPC"),
    6: .same(proto: "NODE_CHANNEL_MANUAL_INPUT"),
    7: .same(proto: "NODE_CHANNEL_VOICE_INPUT"),
    8: .same(proto: "NODE_CHANNEL_BLUETOOTH"),
  ]
}

extension Profilog_Records_BucketSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BucketSize"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_unit"),
    2: .same(proto: "resolution"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.timeUnit) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.resolution) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeUnit != .second {
      try visitor.visitSingularEnumField(value: self.timeUnit, fieldNumber: 1)
    }
    if self.resolution != 0 {
      try visitor.visitSingularInt32Field(value: self.resolution, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_BucketSize, rhs: Profilog_Records_BucketSize) -> Bool {
    if lhs.timeUnit != rhs.timeUnit {return false}
    if lhs.resolution != rhs.resolution {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_BucketSize.TimeUnit: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TIME_UNIT_SECOND"),
    1: .same(proto: "TIME_UNIT_MINUTE"),
    2: .same(proto: "TIME_UNIT_HOUR"),
    3: .same(proto: "TIME_UNIT_DAY"),
    4: .same(proto: "TIME_UNIT_MONTH"),
    5: .same(proto: "TIME_UNIT_WHOLE_RANGE"),
  ]
}

extension Profilog_Records_Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Field"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "numeric"),
    3: .same(proto: "text"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .numeric(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .text(v)
        }
      }()
      case 4: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .timestamp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .timestamp(v)
        }
      }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.value {
    case .numeric?: try {
      guard case .numeric(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }()
    case .text?: try {
      guard case .text(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .timestamp?: try {
      guard case .timestamp(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_Field, rhs: Profilog_Records_Field) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_GetRecordsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRecordsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "medical_subject_id"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .standard(proto: "destination_time_zone_iana_name"),
    5: .standard(proto: "record_groups"),
    99: .standard(proto: "use_new_records"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.medicalSubjectID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._destinationTimeZoneIanaName) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.recordGroups) }()
      case 99: try { try decoder.decodeSingularBoolField(value: &self.useNewRecords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.medicalSubjectID != 0 {
      try visitor.visitSingularInt32Field(value: self.medicalSubjectID, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._destinationTimeZoneIanaName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.recordGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recordGroups, fieldNumber: 5)
    }
    if self.useNewRecords != false {
      try visitor.visitSingularBoolField(value: self.useNewRecords, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_GetRecordsRequest, rhs: Profilog_Records_GetRecordsRequest) -> Bool {
    if lhs.medicalSubjectID != rhs.medicalSubjectID {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs._destinationTimeZoneIanaName != rhs._destinationTimeZoneIanaName {return false}
    if lhs.recordGroups != rhs.recordGroups {return false}
    if lhs.useNewRecords != rhs.useNewRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_GetRecordsRequest.RecordGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_GetRecordsRequest.protoMessageName + ".RecordGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_type_name"),
    2: .same(proto: "sources"),
    3: .standard(proto: "excluded_sources"),
    4: .standard(proto: "do_merge"),
    5: .standard(proto: "bucket_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recordTypeName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sources) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.excludedSources) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.doMerge) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._bucketSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.recordTypeName.isEmpty {
      try visitor.visitSingularStringField(value: self.recordTypeName, fieldNumber: 1)
    }
    if !self.sources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sources, fieldNumber: 2)
    }
    if !self.excludedSources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.excludedSources, fieldNumber: 3)
    }
    if self.doMerge != false {
      try visitor.visitSingularBoolField(value: self.doMerge, fieldNumber: 4)
    }
    try { if let v = self._bucketSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_GetRecordsRequest.RecordGroup, rhs: Profilog_Records_GetRecordsRequest.RecordGroup) -> Bool {
    if lhs.recordTypeName != rhs.recordTypeName {return false}
    if lhs.sources != rhs.sources {return false}
    if lhs.excludedSources != rhs.excludedSources {return false}
    if lhs.doMerge != rhs.doMerge {return false}
    if lhs._bucketSize != rhs._bucketSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_GetRecordsRequest.SourceFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_GetRecordsRequest.protoMessageName + ".SourceFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .same(proto: "origin"),
    4: .standard(proto: "partial_match"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.partialMatch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.partialMatch != false {
      try visitor.visitSingularBoolField(value: self.partialMatch, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_GetRecordsRequest.SourceFilter, rhs: Profilog_Records_GetRecordsRequest.SourceFilter) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs._origin != rhs._origin {return false}
    if lhs.partialMatch != rhs.partialMatch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_GetRecordsRequest.NodeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_GetRecordsRequest.protoMessageName + ".NodeFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "channel"),
    3: .same(proto: "provider"),
    4: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._provider) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._provider {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._level {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_GetRecordsRequest.NodeFilter, rhs: Profilog_Records_GetRecordsRequest.NodeFilter) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._channel != rhs._channel {return false}
    if lhs._provider != rhs._provider {return false}
    if lhs._level != rhs._level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_GetRecordsRequest.NodeFilter.ChannelFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_GetRecordsRequest.NodeFilter.protoMessageName + ".ChannelFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.channel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channel != .unknown {
      try visitor.visitSingularEnumField(value: self.channel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_GetRecordsRequest.NodeFilter.ChannelFilter, rhs: Profilog_Records_GetRecordsRequest.NodeFilter.ChannelFilter) -> Bool {
    if lhs.channel != rhs.channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_GetRecordsRequest.NodeFilter.TypeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_GetRecordsRequest.NodeFilter.protoMessageName + ".TypeFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_GetRecordsRequest.NodeFilter.TypeFilter, rhs: Profilog_Records_GetRecordsRequest.NodeFilter.TypeFilter) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_GetRecordsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRecordsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "medical_subject_id"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .standard(proto: "time_zone_iana_name"),
    5: .standard(proto: "record_groups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.medicalSubjectID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.timeZoneIanaName) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.recordGroups) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.medicalSubjectID != 0 {
      try visitor.visitSingularInt32Field(value: self.medicalSubjectID, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.timeZoneIanaName.isEmpty {
      try visitor.visitSingularStringField(value: self.timeZoneIanaName, fieldNumber: 4)
    }
    if !self.recordGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recordGroups, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_GetRecordsResponse, rhs: Profilog_Records_GetRecordsResponse) -> Bool {
    if lhs.medicalSubjectID != rhs.medicalSubjectID {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.timeZoneIanaName != rhs.timeZoneIanaName {return false}
    if lhs.recordGroups != rhs.recordGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_GetRecordsResponse.RecordGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_GetRecordsResponse.protoMessageName + ".RecordGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_type_name"),
    2: .standard(proto: "raw_records"),
    3: .standard(proto: "bucket_records"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recordTypeName) }()
      case 2: try {
        var v: Profilog_Records_GetRecordsResponse.RawRecords?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .rawRecords(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .rawRecords(v)
        }
      }()
      case 3: try {
        var v: Profilog_Records_GetRecordsResponse.BucketRecords?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .bucketRecords(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .bucketRecords(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.recordTypeName.isEmpty {
      try visitor.visitSingularStringField(value: self.recordTypeName, fieldNumber: 1)
    }
    switch self.data {
    case .rawRecords?: try {
      guard case .rawRecords(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .bucketRecords?: try {
      guard case .bucketRecords(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_GetRecordsResponse.RecordGroup, rhs: Profilog_Records_GetRecordsResponse.RecordGroup) -> Bool {
    if lhs.recordTypeName != rhs.recordTypeName {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_GetRecordsResponse.RawRecords: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_GetRecordsResponse.protoMessageName + ".RawRecords"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_merged"),
    2: .same(proto: "records"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isMerged) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isMerged != false {
      try visitor.visitSingularBoolField(value: self.isMerged, fieldNumber: 1)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_GetRecordsResponse.RawRecords, rhs: Profilog_Records_GetRecordsResponse.RawRecords) -> Bool {
    if lhs.isMerged != rhs.isMerged {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_GetRecordsResponse.Record: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_GetRecordsResponse.protoMessageName + ".Record"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_at"),
    2: .standard(proto: "end_at"),
    3: .same(proto: "source"),
    4: .same(proto: "fields"),
    5: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 4)
    }
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_GetRecordsResponse.Record, rhs: Profilog_Records_GetRecordsResponse.Record) -> Bool {
    if lhs._startAt != rhs._startAt {return false}
    if lhs._endAt != rhs._endAt {return false}
    if lhs._source != rhs._source {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_GetRecordsResponse.Source: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_GetRecordsResponse.protoMessageName + ".Source"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .same(proto: "origin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_GetRecordsResponse.Source, rhs: Profilog_Records_GetRecordsResponse.Source) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs._origin != rhs._origin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_GetRecordsResponse.Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_GetRecordsResponse.protoMessageName + ".Node"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "provider"),
    3: .same(proto: "level"),
    4: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.channel) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.provider) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channel != .unknown {
      try visitor.visitSingularEnumField(value: self.channel, fieldNumber: 1)
    }
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 2)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 3)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_GetRecordsResponse.Node, rhs: Profilog_Records_GetRecordsResponse.Node) -> Bool {
    if lhs.channel != rhs.channel {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.level != rhs.level {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_GetRecordsResponse.BucketRecords: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_GetRecordsResponse.protoMessageName + ".BucketRecords"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bucket_size"),
    2: .same(proto: "buckets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bucketSize) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.buckets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bucketSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.buckets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buckets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_GetRecordsResponse.BucketRecords, rhs: Profilog_Records_GetRecordsResponse.BucketRecords) -> Bool {
    if lhs._bucketSize != rhs._bucketSize {return false}
    if lhs.buckets != rhs.buckets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_GetRecordsResponse.Bucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_GetRecordsResponse.protoMessageName + ".Bucket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_at"),
    2: .standard(proto: "end_at"),
    3: .standard(proto: "aggregated_fields"),
    5: .standard(proto: "aggregation_metrics"),
    4: .same(proto: "sources"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endAt) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.aggregatedFields) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.sources) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.aggregationMetrics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.aggregatedFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aggregatedFields, fieldNumber: 3)
    }
    if !self.sources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sources, fieldNumber: 4)
    }
    if !self.aggregationMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aggregationMetrics, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_GetRecordsResponse.Bucket, rhs: Profilog_Records_GetRecordsResponse.Bucket) -> Bool {
    if lhs._startAt != rhs._startAt {return false}
    if lhs._endAt != rhs._endAt {return false}
    if lhs.aggregatedFields != rhs.aggregatedFields {return false}
    if lhs.aggregationMetrics != rhs.aggregationMetrics {return false}
    if lhs.sources != rhs.sources {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_GetRecordsResponse.AggregatedField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_GetRecordsResponse.protoMessageName + ".AggregatedField"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "count"),
    3: .same(proto: "max"),
    4: .same(proto: "min"),
    5: .same(proto: "avg"),
    6: .same(proto: "sum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.max) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.min) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.avg) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.sum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 2)
    }
    if self.max != 0 {
      try visitor.visitSingularDoubleField(value: self.max, fieldNumber: 3)
    }
    if self.min != 0 {
      try visitor.visitSingularDoubleField(value: self.min, fieldNumber: 4)
    }
    if self.avg != 0 {
      try visitor.visitSingularDoubleField(value: self.avg, fieldNumber: 5)
    }
    if self.sum != 0 {
      try visitor.visitSingularDoubleField(value: self.sum, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_GetRecordsResponse.AggregatedField, rhs: Profilog_Records_GetRecordsResponse.AggregatedField) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.count != rhs.count {return false}
    if lhs.max != rhs.max {return false}
    if lhs.min != rhs.min {return false}
    if lhs.avg != rhs.avg {return false}
    if lhs.sum != rhs.sum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_GetRecordsResponse.AggregationMetric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_GetRecordsResponse.protoMessageName + ".AggregationMetric"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_GetRecordsResponse.AggregationMetric, rhs: Profilog_Records_GetRecordsResponse.AggregationMetric) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_SaveRecordsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SaveRecordsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "medical_subject_id"),
    2: .standard(proto: "create_session"),
    3: .standard(proto: "time_zone_iana_name"),
    4: .standard(proto: "record_groups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.medicalSubjectID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.createSession) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.timeZoneIanaName) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.recordGroups) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.medicalSubjectID != 0 {
      try visitor.visitSingularInt32Field(value: self.medicalSubjectID, fieldNumber: 1)
    }
    if self.createSession != false {
      try visitor.visitSingularBoolField(value: self.createSession, fieldNumber: 2)
    }
    if !self.timeZoneIanaName.isEmpty {
      try visitor.visitSingularStringField(value: self.timeZoneIanaName, fieldNumber: 3)
    }
    if !self.recordGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recordGroups, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_SaveRecordsRequest, rhs: Profilog_Records_SaveRecordsRequest) -> Bool {
    if lhs.medicalSubjectID != rhs.medicalSubjectID {return false}
    if lhs.createSession != rhs.createSession {return false}
    if lhs.timeZoneIanaName != rhs.timeZoneIanaName {return false}
    if lhs.recordGroups != rhs.recordGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_SaveRecordsRequest.RecordGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_SaveRecordsRequest.protoMessageName + ".RecordGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_type_name"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .same(proto: "source"),
    5: .same(proto: "records"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recordTypeName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.recordTypeName.isEmpty {
      try visitor.visitSingularStringField(value: self.recordTypeName, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_SaveRecordsRequest.RecordGroup, rhs: Profilog_Records_SaveRecordsRequest.RecordGroup) -> Bool {
    if lhs.recordTypeName != rhs.recordTypeName {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs._source != rhs._source {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_SaveRecordsRequest.Source: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_SaveRecordsRequest.protoMessageName + ".Source"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .same(proto: "origin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_SaveRecordsRequest.Source, rhs: Profilog_Records_SaveRecordsRequest.Source) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs._origin != rhs._origin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_SaveRecordsRequest.Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_SaveRecordsRequest.protoMessageName + ".Node"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "provider"),
    3: .same(proto: "level"),
    4: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.channel) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.provider) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channel != .unknown {
      try visitor.visitSingularEnumField(value: self.channel, fieldNumber: 1)
    }
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 2)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 3)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_SaveRecordsRequest.Node, rhs: Profilog_Records_SaveRecordsRequest.Node) -> Bool {
    if lhs.channel != rhs.channel {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.level != rhs.level {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_SaveRecordsRequest.Record: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Profilog_Records_SaveRecordsRequest.protoMessageName + ".Record"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_at"),
    2: .standard(proto: "end_at"),
    3: .same(proto: "fields"),
    4: .same(proto: "origin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endAt) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 3)
    }
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_SaveRecordsRequest.Record, rhs: Profilog_Records_SaveRecordsRequest.Record) -> Bool {
    if lhs._startAt != rhs._startAt {return false}
    if lhs._endAt != rhs._endAt {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs._origin != rhs._origin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Profilog_Records_SaveRecordsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SaveRecordsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Profilog_Records_SaveRecordsResponse, rhs: Profilog_Records_SaveRecordsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
